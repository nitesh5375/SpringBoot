QUESTION:
When a method annotated with @Transactional executes, Spring starts a database transaction before the method begins. what does it mean?

ANSWER:
Assume you have:
@Transactional
public void updateUser() {
    userRepository.save(...);
}
Step-by-step explanation
1Ô∏è‚É£ Spring opens a DB transaction BEFORE the method body runs
Spring tells the database something like:
BEGIN TRANSACTION;
(or the equivalent depending on the DB vendor)
This means:
All SQL operations inside this method will now run inside one single atomic transaction.
They will not be permanently saved until Spring issues a COMMIT.
The important idea:
‚û°Ô∏è The moment control enters the method, a transaction context already exists.
2Ô∏è‚É£ All repository calls inside the method participate in THIS transaction
Example:
userRepo.save(user);   // part of the same transaction
orderRepo.save(order); // same transaction
If any of these fail ‚Üí everything rolls back.
3Ô∏è‚É£ After the method completes, Spring decides:
‚úî If no exception ‚Üí Spring sends COMMIT
DB now permanently saves:
COMMIT;
‚ùå If an exception occurs ‚Üí Spring sends ROLLBACK
DB discards all SQL operations:
ROLLBACK;
üîç Why does Spring need to start the transaction before entering the method?
Because:
If you run multiple SQL updates, they must belong to the same atomic block.
You cannot start/commit a transaction after some SQL has already executed.
Spring must prepare the transactional context for the entire method.
üß† Example timeline
With @Transactional:
[Spring] BEGIN
   ‚Üì
execute method
   ‚Üì
[Spring] COMMIT or ROLLBACK
Without @Transactional:
Every SQL executes independently:
SQL1 committed immediately
SQL2 committed immediately
SQL3 committed immediately
If SQL3 fails ‚Üí SQL1 and SQL2 are already saved ‚Üí ‚ùå inconsistent state.

<--------------------------------------------------------------------------------------------------------------------->
QUESTION:
what happens if a method inside a transactional class is marked as @Transactional(propagation = Propagation.REQUIRES_NEW)

ANSWER:
‚úÖ What does REQUIRES_NEW mean?
When a method is annotated with REQUIRES_NEW, Spring:
Suspends the currently running transaction (if any)
Starts a brand-new independent transaction
When the method finishes ‚Üí commits or rolls back independently
Then resumes the original transaction
‚úÖ Where is it useful?
Logging events that must be saved even if main transaction fails
Sending emails / audit logs
Saving partial progress
Retrying operations
Compensating transactions
‚≠ê Complete Example
Imagine an order placement process:
‚ñ∂ Main flow (big transaction)
Save order
Deduct inventory
Charge payment
‚ñ∂ But you always want to save an audit log
EVEN IF order creation fails.
üìå Java Code Example
@Service
public class OrderService {
    @Autowired
    private PaymentService paymentService;
    @Autowired
    private AuditService auditService;
    @Transactional
    public void placeOrder(Order order) {
        // MAIN TRANSACTION STARTS
        // Step 1: save the order
        saveOrder(order);
        // Step 2: try payment
        try {
            paymentService.chargeCustomer(order);
        } catch (Exception e) {
            // Payment failed ‚Üí order fails
            // BUT AUDIT LOG MUST STILL BE SAVED
            auditService.saveAuditLog("Payment failed for order " + order.getId());
            throw e;
        }
        // Step 3: successful
        auditService.saveAuditLog("Order placed successfully: " + order.getId());
        // MAIN TRANSACTION COMMITS (unless an exception)
    }
}
üìå Audit Service with REQUIRES_NEW
@Service
public class AuditService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveAuditLog(String message) {
        AuditLog log = new AuditLog();
        log.setMessage(message);
        log.setTimestamp(LocalDateTime.now());
        // SAVE in a NEW TRANSACTION
        auditLogRepository.save(log);
    }
}
‚≠ê What happens step-by-step?
Case 1 ‚Üí PAYMENT FAILS
Part	Transaction	Result
placeOrder()	T1	Rolls back
saveAuditLog()	T2 (NEW)	Commits successfully
‚û° Audit success message is saved even though order failed.
Case 2 ‚Üí ORDER SUCCESS
Both logs:
"Order placed successfully‚Ä¶" ‚Üí committed in T2
Entire order logic ‚Üí committed in T1
üî• Visual Transaction Flow
placeOrder() -- starts Transaction T1
    |
    |-- chargeCustomer() --> fails
    |
    |-- saveAuditLog() -- starts Transaction T2
    |        |
    |        |-- T2 commits independently
    |
T1 rolls back

Note: if T2 fails, does not mean T1 will also rollback. and if T1 fails, T1 is paused and